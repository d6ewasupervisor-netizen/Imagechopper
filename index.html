<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Zone Selector</title>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      min-height: 100vh;
      min-height: -webkit-fill-available;
      background: linear-gradient(145deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      color: #e0e0e0;
      padding: 12px;
      overflow-x: hidden;
    }

    html { height: -webkit-fill-available; }

    .container { max-width: 1400px; margin: 0 auto; }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      padding: 12px 16px;
      background: rgba(255,255,255,0.03);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      flex-wrap: wrap;
      gap: 10px;
    }

    h1 {
      font-size: 1.2rem;
      font-weight: 700;
      background: linear-gradient(90deg, #00d4ff, #7b68ee);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .header-buttons { display: flex; gap: 8px; flex-wrap: wrap; }

    .btn {
      padding: 12px 18px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.85rem;
      border: none;
      font-family: inherit;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    .load-btn {
      background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
      color: #0a0a0a;
      box-shadow: 0 4px 15px rgba(0,212,255,0.3);
    }

    .clear-btn {
      background: rgba(255,100,100,0.2);
      border: 1px solid rgba(255,100,100,0.4);
      color: #ff6464;
    }

    .main-content { display: flex; flex-direction: column; gap: 12px; }

    @media (min-width: 900px) {
      .main-content { flex-direction: row; gap: 20px; }
      .sidebar { width: 280px; }
    }

    /* Toolbar styles */
    .toolbar {
      display: flex;
      gap: 6px;
      padding: 10px 14px;
      background: rgba(0,0,0,0.3);
      border-radius: 10px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    .toolbar-label {
      font-size: 0.75rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-right: 8px;
    }

    .tool-btn {
      padding: 10px 14px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.8rem;
      border: 1px solid rgba(255,255,255,0.1);
      font-family: inherit;
      background: rgba(255,255,255,0.05);
      color: #888;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .tool-btn:hover {
      background: rgba(255,255,255,0.1);
      color: #aaa;
    }

    .tool-btn.active {
      background: linear-gradient(135deg, #7b68ee 0%, #5a4fcf 100%);
      color: #fff;
      border-color: transparent;
      box-shadow: 0 2px 10px rgba(123,104,238,0.3);
    }

    .tool-icon {
      font-size: 1rem;
    }

    .toolbar-divider {
      width: 1px;
      height: 28px;
      background: rgba(255,255,255,0.15);
      margin: 0 8px;
    }

    .undo-btn:disabled, .redo-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .canvas-area {
      flex: 1;
      background: rgba(0,0,0,0.4);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      padding: 12px;
      display: flex;
      flex-direction: column;
      min-height: 300px;
      position: relative;
      overflow: hidden;
      touch-action: none;
    }

    .canvas-content {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .placeholder {
      text-align: center;
      color: #666;
    }

    .placeholder-icon { font-size: 3rem; margin-bottom: 16px; }

    .image-container {
      position: relative;
      display: none;
      touch-action: none;
    }

    .image-container img {
      display: block;
      pointer-events: none;
      -webkit-user-drag: none;
      user-select: none;
    }

    /* SVG overlay for drawing shapes */
    .svg-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .svg-overlay.interactive {
      pointer-events: auto;
    }

    /* Zone shapes */
    .zone-shape {
      fill: rgba(0,212,255,0.15);
      stroke: #00d4ff;
      stroke-width: 2;
      cursor: move;
      pointer-events: auto;
    }

    .zone-shape.selected {
      fill: rgba(123,104,238,0.2);
      stroke: #7b68ee;
    }

    .zone-shape:hover {
      fill: rgba(0,212,255,0.25);
    }

    .zone-shape.selected:hover {
      fill: rgba(123,104,238,0.3);
    }

    .zone-shape.multi-selected {
      fill: rgba(255,200,100,0.2);
      stroke: #ffc864;
      stroke-width: 2;
      stroke-dasharray: 4,2;
    }

    .zone-shape.multi-selected:hover {
      fill: rgba(255,200,100,0.3);
    }

    .zone-shape.dragging {
      cursor: grabbing;
      opacity: 0.8;
    }

    /* Anchor points */
    .anchor-point {
      fill: #7b68ee;
      stroke: #fff;
      stroke-width: 2;
      cursor: grab;
      pointer-events: auto;
      transition: transform 0.1s, fill 0.1s;
    }

    .anchor-point:hover {
      fill: #9d8eff;
      transform: scale(1.3);
      transform-origin: center;
      transform-box: fill-box;
    }

    .anchor-point.dragging {
      fill: #ff6464;
      cursor: grabbing;
      transform: scale(1.5);
      transform-origin: center;
      transform-box: fill-box;
    }

    .anchor-point.first-anchor {
      fill: #00d4ff;
      stroke: #fff;
    }

    .anchor-point.first-anchor:hover {
      fill: #33ddff;
    }

    /* Anchor hit area (invisible, larger click target) */
    .anchor-hit-area {
      fill: transparent;
      cursor: grab;
      pointer-events: auto;
    }

    .anchor-hit-area:hover + .anchor-point {
      fill: #9d8eff;
      transform: scale(1.3);
      transform-origin: center;
      transform-box: fill-box;
    }

    /* Drawing preview */
    .drawing-preview {
      fill: rgba(123,104,238,0.2);
      stroke: #7b68ee;
      stroke-width: 2;
      stroke-dasharray: 5,5;
      pointer-events: none;
    }

    .drawing-line {
      stroke: #7b68ee;
      stroke-width: 2;
      stroke-dasharray: 5,5;
      pointer-events: none;
    }

    /* Zone labels */
    .zone-label-svg {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      font-weight: 700;
      fill: #0a0a0a;
      pointer-events: none;
    }

    .zone-label-bg {
      fill: #00d4ff;
      pointer-events: none;
    }

    .zone-label-bg.selected {
      fill: #7b68ee;
    }

    .zone-label-bg.multi-selected {
      fill: #ffc864;
    }

    /* Edge highlight for adding anchors */
    .edge-highlight {
      stroke: #ffcc00;
      stroke-width: 4;
      stroke-linecap: round;
      pointer-events: auto;
      cursor: crosshair;
      opacity: 0;
    }

    .edge-highlight:hover {
      opacity: 0.6;
    }

    .sidebar {
      background: rgba(255,255,255,0.03);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .field-label {
      display: block;
      margin-bottom: 8px;
      font-size: 0.8rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .text-input {
      width: 100%;
      padding: 14px;
      background: rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 8px;
      color: #e0e0e0;
      font-family: inherit;
      font-size: 16px;
      -webkit-appearance: none;
    }

    .text-input:focus {
      outline: none;
      border-color: #00d4ff;
    }

    .zones-list { overflow: auto; max-height: 200px; }

    @media (min-width: 900px) {
      .zones-list { flex: 1; max-height: none; }
    }

    .empty-msg { color: #555; font-size: 0.85rem; }

    .zone-items { display: flex; flex-direction: column; gap: 8px; }

    .zone-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      background: rgba(0,212,255,0.1);
      border: 1px solid rgba(0,212,255,0.3);
      border-radius: 6px;
      font-size: 0.85rem;
      cursor: pointer;
    }

    .zone-item.selected {
      background: rgba(123,104,238,0.2);
      border-color: rgba(123,104,238,0.5);
    }

    .zone-item strong { color: #00d4ff; }
    .zone-item.selected strong { color: #7b68ee; }
    .zone-item.multi-selected {
      background: rgba(255,200,100,0.15);
      border-color: rgba(255,200,100,0.4);
    }
    .zone-item.multi-selected strong { color: #ffc864; }
    .zone-item .dims { color: #666; margin-left: 8px; }
    .zone-item .type-badge {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(255,255,255,0.1);
      color: #888;
      margin-left: 6px;
    }

    /* Multi-select controls */
    .selection-controls {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
    }

    .selection-btn {
      flex: 1;
      padding: 8px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      font-size: 0.75rem;
      border: 1px solid rgba(255,255,255,0.15);
      font-family: inherit;
      background: rgba(255,255,255,0.05);
      color: #888;
      transition: all 0.2s;
      touch-action: manipulation;
    }

    .selection-btn:hover {
      background: rgba(255,255,255,0.1);
      color: #aaa;
    }

    .selection-btn.active {
      background: linear-gradient(135deg, #ffc864 0%, #e6a030 100%);
      color: #0a0a0a;
      border-color: transparent;
      box-shadow: 0 2px 8px rgba(255,200,100,0.3);
    }

    .selection-btn.clear-selection {
      background: rgba(255,100,100,0.15);
      border-color: rgba(255,100,100,0.3);
      color: #ff6464;
    }

    .selection-btn.clear-selection:hover {
      background: rgba(255,100,100,0.25);
    }

    .selection-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .delete-btn {
      background: rgba(255,100,100,0.2);
      border: 1px solid rgba(255,100,100,0.4);
      border-radius: 4px;
      color: #ff6464;
      cursor: pointer;
      padding: 8px 12px;
      font-size: 0.85rem;
      font-family: inherit;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    .export-btn {
      padding: 16px 20px;
      background: linear-gradient(135deg, #7b68ee 0%, #5a4fcf 100%);
      border: none;
      border-radius: 8px;
      color: #fff;
      font-family: inherit;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(123,104,238,0.4);
      transition: all 0.2s;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    .export-btn:disabled {
      background: rgba(100,100,100,0.3);
      color: #666;
      cursor: not-allowed;
      box-shadow: none;
    }

    .hint-bar {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 0.8rem;
      text-align: center;
      color: #888;
      line-height: 1.5;
    }

    /* Preset panel styles */
    .preset-panel {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 12px;
    }

    .preset-category {
      margin-bottom: 10px;
    }

    .preset-category:last-child {
      margin-bottom: 0;
    }

    .preset-category-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      padding: 8px 10px;
      background: rgba(255,255,255,0.05);
      border-radius: 6px;
      font-size: 0.75rem;
      color: #aaa;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: background 0.2s;
    }

    .preset-category-header:hover {
      background: rgba(255,255,255,0.08);
    }

    .preset-category-header .arrow {
      transition: transform 0.2s;
    }

    .preset-category.expanded .preset-category-header .arrow {
      transform: rotate(90deg);
    }

    .preset-options {
      display: none;
      flex-wrap: wrap;
      gap: 6px;
      padding: 8px 4px 4px 4px;
    }

    .preset-category.expanded .preset-options {
      display: flex;
    }

    .preset-btn {
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 500;
      font-size: 0.75rem;
      border: 1px solid rgba(0,212,255,0.3);
      font-family: inherit;
      background: rgba(0,212,255,0.1);
      color: #00d4ff;
      transition: all 0.2s;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    .preset-btn:hover {
      background: rgba(0,212,255,0.2);
      border-color: rgba(0,212,255,0.5);
    }

    .preset-btn:active {
      background: rgba(0,212,255,0.3);
    }

    .preset-btn.social {
      border-color: rgba(255,100,200,0.3);
      background: rgba(255,100,200,0.1);
      color: #ff64c8;
    }

    .preset-btn.social:hover {
      background: rgba(255,100,200,0.2);
      border-color: rgba(255,100,200,0.5);
    }

    .preset-btn.print {
      border-color: rgba(100,255,150,0.3);
      background: rgba(100,255,150,0.1);
      color: #64ff96;
    }

    .preset-btn.print:hover {
      background: rgba(100,255,150,0.2);
      border-color: rgba(100,255,150,0.5);
    }

    .preset-btn.composition {
      border-color: rgba(255,200,100,0.3);
      background: rgba(255,200,100,0.1);
      color: #ffc864;
    }

    .preset-btn.composition:hover {
      background: rgba(255,200,100,0.2);
      border-color: rgba(255,200,100,0.5);
    }

    .preset-btn.mosaic {
      border-color: rgba(150,100,255,0.3);
      background: rgba(150,100,255,0.1);
      color: #9664ff;
    }

    .preset-btn.mosaic:hover {
      background: rgba(150,100,255,0.2);
      border-color: rgba(150,100,255,0.5);
    }

    .preset-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .preset-info {
      font-size: 0.7rem;
      color: #666;
      padding: 6px 8px;
      line-height: 1.4;
    }

    /* Mobile touch optimizations */
    @media (max-width: 768px) {
      .anchor-point {
        transform: scale(1.2);
        transform-origin: center;
        transform-box: fill-box;
      }

      .anchor-hit-area {
        /* Even larger hit areas on mobile */
        transform: scale(1.3);
        transform-origin: center;
        transform-box: fill-box;
      }

      .zone-item {
        padding: 14px 16px;
        min-height: 48px;
      }

      .delete-btn {
        padding: 10px 14px;
        min-width: 44px;
        min-height: 44px;
      }

      .selection-btn {
        padding: 12px;
        min-height: 44px;
      }

      .tool-btn {
        padding: 12px 14px;
        min-height: 44px;
      }

      .btn {
        padding: 14px 18px;
        min-height: 44px;
      }

      .preset-btn {
        padding: 10px 14px;
        min-height: 40px;
      }
    }

    /* Touch feedback */
    @media (hover: none) {
      .zone-shape:active {
        fill: rgba(123,104,238,0.4);
      }

      .anchor-point:active {
        fill: #ff6464;
        transform: scale(1.5);
      }

      .zone-item:active {
        background: rgba(123,104,238,0.3);
      }

      .tool-btn:active {
        background: rgba(123,104,238,0.3);
      }

      .selection-btn:active {
        background: rgba(255,200,100,0.3);
      }
    }

    /* Prevent text selection during drag */
    .image-container {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Zone Selector</h1>
      <div class="header-buttons">
        <input type="file" id="fileInput" accept="image/*" style="display: none;">
        <button class="btn load-btn" onclick="document.getElementById('fileInput').click()">Load Image</button>
        <button class="btn clear-btn" onclick="clearAllZones()">Clear All</button>
      </div>
    </header>

    <div class="main-content">
      <div class="canvas-area" id="canvasArea">
        <div class="toolbar" id="toolbar">
          <span class="toolbar-label">Tools:</span>
          <button class="tool-btn" data-tool="pointer" onclick="setTool('pointer')">
            <span class="tool-icon">â†–</span> Pointer
          </button>
          <button class="tool-btn active" data-tool="rectangle" onclick="setTool('rectangle')">
            <span class="tool-icon">â–¢</span> Rectangle
          </button>
          <button class="tool-btn" data-tool="circle" onclick="setTool('circle')">
            <span class="tool-icon">â—‹</span> Circle
          </button>
          <button class="tool-btn" data-tool="polygon" onclick="setTool('polygon')">
            <span class="tool-icon">â¬¡</span> Polygon
          </button>
          <button class="tool-btn" data-tool="freehand" onclick="setTool('freehand')">
            <span class="tool-icon">âœŽ</span> Freehand
          </button>
          <span class="toolbar-divider"></span>
          <button class="tool-btn undo-btn" onclick="undo()" title="Undo (Ctrl+Z)">
            <span class="tool-icon">â†©</span> Undo
          </button>
          <button class="tool-btn redo-btn" onclick="redo()" title="Redo (Ctrl+Y)">
            <span class="tool-icon">â†ª</span> Redo
          </button>
        </div>

        <div class="canvas-content">
          <div class="placeholder" id="placeholder">
            <div class="placeholder-icon">ðŸ“·</div>
            <p>Load an image to begin</p>
          </div>
          <div class="image-container" id="imageContainer">
            <img id="mainImage" src="" alt="Loaded image">
            <svg class="svg-overlay" id="svgOverlay"></svg>
          </div>
        </div>
      </div>

      <div class="sidebar">
        <div class="hint-bar" id="hintBar">
          Select a tool and draw on the image
        </div>

        <div class="preset-panel">
          <label class="field-label">Grid Presets</label>

          <!-- Rule of Thirds -->
          <div class="preset-category" id="catComposition">
            <div class="preset-category-header" onclick="togglePresetCategory('catComposition')">
              <span>Compositional Grids</span>
              <span class="arrow">â–¶</span>
            </div>
            <div class="preset-options">
              <button class="preset-btn composition" onclick="applyPreset('rule-of-thirds')" title="Divides image into 9 equal parts">Rule of Thirds</button>
              <button class="preset-btn composition" onclick="applyPreset('phi-grid')" title="Golden Ratio (1:1.618) grid">Phi Grid</button>
              <button class="preset-btn composition" onclick="applyPreset('golden-triangle')" title="Diagonal composition grid">Golden Triangle</button>
              <div class="preset-info">For balanced, aesthetically pleasing compositions</div>
            </div>
          </div>

          <!-- Social Media -->
          <div class="preset-category" id="catSocial">
            <div class="preset-category-header" onclick="togglePresetCategory('catSocial')">
              <span>Social Media Grids</span>
              <span class="arrow">â–¶</span>
            </div>
            <div class="preset-options">
              <button class="preset-btn social" onclick="applyPreset('social-1x1-3')" title="3 square tiles for Instagram grid">1:1 Ã— 3</button>
              <button class="preset-btn social" onclick="applyPreset('social-1x1-9')" title="9 square tiles for Instagram puzzle">1:1 Ã— 9</button>
              <button class="preset-btn social" onclick="applyPreset('social-4x5')" title="Instagram portrait (max feed space)">4:5 Portrait</button>
              <button class="preset-btn social" onclick="applyPreset('social-9x16')" title="Stories, Reels, TikTok">9:16 Vertical</button>
              <div class="preset-info">Instagram, TikTok, Stories & Reels</div>
            </div>
          </div>

          <!-- Print Ratios -->
          <div class="preset-category" id="catPrint">
            <div class="preset-category-header" onclick="togglePresetCategory('catPrint')">
              <span>Print Aspect Ratios</span>
              <span class="arrow">â–¶</span>
            </div>
            <div class="preset-options">
              <button class="preset-btn print" onclick="applyPreset('ratio-3x2')" title="35mm / DSLR / 4Ã—6 prints">3:2</button>
              <button class="preset-btn print" onclick="applyPreset('ratio-4x3')" title="Micro 4/3 / Smartphones">4:3</button>
              <button class="preset-btn print" onclick="applyPreset('ratio-5x4')" title="8Ã—10 prints">5:4</button>
              <button class="preset-btn print" onclick="applyPreset('ratio-16x9')" title="Widescreen / Cinematic">16:9</button>
              <div class="preset-info">Standard print and display ratios</div>
            </div>
          </div>

          <!-- Mosaic/Splitter -->
          <div class="preset-category" id="catMosaic">
            <div class="preset-category-header" onclick="togglePresetCategory('catMosaic')">
              <span>Mosaic Splitter</span>
              <span class="arrow">â–¶</span>
            </div>
            <div class="preset-options">
              <button class="preset-btn mosaic" onclick="applyPreset('mosaic-2x2')" title="4 equal tiles">2Ã—2</button>
              <button class="preset-btn mosaic" onclick="applyPreset('mosaic-3x3')" title="9 equal tiles">3Ã—3</button>
              <button class="preset-btn mosaic" onclick="applyPreset('mosaic-4x4')" title="16 equal tiles">4Ã—4</button>
              <button class="preset-btn mosaic" onclick="applyPreset('mosaic-2x3')" title="6 equal tiles">2Ã—3</button>
              <button class="preset-btn mosaic" onclick="applyPreset('mosaic-3x1')" title="3 horizontal tiles">3Ã—1</button>
              <button class="preset-btn mosaic" onclick="applyPreset('mosaic-1x3')" title="3 vertical tiles">1Ã—3</button>
              <div class="preset-info">Split image into equal tiles</div>
            </div>
          </div>
        </div>

        <div>
          <label class="field-label">Base Filename</label>
          <input type="text" id="baseName" class="text-input" value="zone" placeholder="zone">
        </div>

        <div class="zones-list">
          <div class="field-label">Zones (<span id="zoneCount">0</span>)</div>
          <div class="selection-controls" id="selectionControls">
            <button class="selection-btn" id="multiSelectBtn" onclick="toggleMultiSelectMode()" title="Enable multi-select mode to select multiple zones">Multi-Select</button>
            <button class="selection-btn clear-selection" id="clearSelectionBtn" onclick="clearAllSelections()" disabled title="Clear all selections">Clear Selection</button>
          </div>
          <p class="empty-msg" id="emptyMsg">Draw shapes on the image</p>
          <div class="zone-items" id="zoneItems"></div>
        </div>

        <button class="export-btn" id="exportBtn" disabled onclick="exportZones()">Export 0 Zones</button>
      </div>
    </div>
  </div>

  <script>
    // State
    let originalImage = null;
    let scale = 1;
    let zones = [];
    let selectedZoneId = null;
    let selectedZoneIds = []; // For multi-selection
    let multiSelectMode = false;
    let currentTool = 'rectangle';

    // Interaction state
    let action = null;
    let startX = 0, startY = 0;
    let startZone = null;
    let startZones = []; // For multi-zone movement
    let draggedAnchorIndex = null;
    let isDragging = false;

    // Polygon drawing state
    let polygonPoints = [];
    let isDrawingPolygon = false;

    // Freehand drawing state
    let freehandPoints = [];
    let isDrawingFreehand = false;

    // Double-click detection
    let lastClickTime = 0;
    let lastClickPos = { x: 0, y: 0 };

    // Undo/Redo state (max 10 steps each direction)
    const MAX_HISTORY = 10;
    let undoStack = [];
    let redoStack = [];

    // DOM elements
    const fileInput = document.getElementById('fileInput');
    const placeholder = document.getElementById('placeholder');
    const imageContainer = document.getElementById('imageContainer');
    const mainImage = document.getElementById('mainImage');
    const svgOverlay = document.getElementById('svgOverlay');
    const canvasArea = document.getElementById('canvasArea');
    const zoneCount = document.getElementById('zoneCount');
    const emptyMsg = document.getElementById('emptyMsg');
    const zoneItems = document.getElementById('zoneItems');
    const exportBtn = document.getElementById('exportBtn');
    const baseNameInput = document.getElementById('baseName');
    const hintBar = document.getElementById('hintBar');
    const multiSelectBtn = document.getElementById('multiSelectBtn');
    const clearSelectionBtn = document.getElementById('clearSelectionBtn');

    // Tool hints
    const toolHints = {
      pointer: 'Click to select zones â€¢ Drag anchors to resize â€¢ No new shapes will be created',
      rectangle: 'Drag to draw a rectangle â€¢ Click zone to select â€¢ Drag corners to resize',
      circle: 'Drag to draw a circle/ellipse â€¢ Click zone to select â€¢ Drag anchors to resize',
      polygon: 'Click to add points â€¢ Click first point to close â€¢ Double-click edge to add point',
      freehand: 'Click and drag to draw freely â€¢ Release to complete shape'
    };

    function setTool(tool) {
      currentTool = tool;
      document.querySelectorAll('.tool-btn').forEach(btn => {
        if (btn.dataset.tool) {
          btn.classList.toggle('active', btn.dataset.tool === tool);
        }
      });
      hintBar.textContent = toolHints[tool];

      // Cancel any in-progress drawing
      cancelDrawing();

      // Update cursor
      if (tool === 'pointer') {
        imageContainer.style.cursor = 'default';
      } else {
        imageContainer.style.cursor = 'crosshair';
      }
    }

    // Toggle multi-select mode
    function toggleMultiSelectMode() {
      multiSelectMode = !multiSelectMode;
      multiSelectBtn.classList.toggle('active', multiSelectMode);

      if (!multiSelectMode) {
        // When exiting multi-select, keep only primary selection
        if (selectedZoneIds.length > 0) {
          selectedZoneId = selectedZoneIds[0];
          selectedZoneIds = [];
        }
      } else {
        // When entering multi-select, add current selection to array
        if (selectedZoneId && !selectedZoneIds.includes(selectedZoneId)) {
          selectedZoneIds = [selectedZoneId];
          selectedZoneId = null;
        }
      }

      updateSelectionButtons();
      updateZonesList();
      renderZones();
    }

    // Clear all selections
    function clearAllSelections() {
      selectedZoneId = null;
      selectedZoneIds = [];
      updateSelectionButtons();
      updateZonesList();
      renderZones();
    }

    // Update selection button states
    function updateSelectionButtons() {
      const hasSelections = selectedZoneId !== null || selectedZoneIds.length > 0;
      clearSelectionBtn.disabled = !hasSelections;
    }

    // Check if a zone is selected (either single or multi)
    function isZoneSelected(zoneId) {
      return zoneId === selectedZoneId || selectedZoneIds.includes(zoneId);
    }

    // Get all selected zone IDs
    function getSelectedZoneIds() {
      if (multiSelectMode) {
        return [...selectedZoneIds];
      }
      return selectedZoneId ? [selectedZoneId] : [];
    }

    function cancelDrawing() {
      polygonPoints = [];
      isDrawingPolygon = false;
      freehandPoints = [];
      isDrawingFreehand = false;
      action = null;
      isDragging = false;
      startZones = [];
      renderZones();
    }

    // Save current state for undo
    function saveState() {
      const state = {
        zones: JSON.parse(JSON.stringify(zones)),
        selectedZoneId: selectedZoneId,
        selectedZoneIds: [...selectedZoneIds]
      };
      undoStack.push(state);
      if (undoStack.length > MAX_HISTORY) {
        undoStack.shift();
      }
      // Clear redo stack when new action is performed
      redoStack = [];
      updateUndoRedoButtons();
    }

    // Undo last action
    function undo() {
      if (undoStack.length === 0) return;

      // Save current state to redo stack
      const currentState = {
        zones: JSON.parse(JSON.stringify(zones)),
        selectedZoneId: selectedZoneId,
        selectedZoneIds: [...selectedZoneIds]
      };
      redoStack.push(currentState);
      if (redoStack.length > MAX_HISTORY) {
        redoStack.shift();
      }

      // Restore previous state
      const previousState = undoStack.pop();
      zones = previousState.zones;
      selectedZoneId = previousState.selectedZoneId;
      selectedZoneIds = previousState.selectedZoneIds || [];

      cancelDrawing();
      updateSelectionButtons();
      updateZonesList();
      renderZones();
      updateUndoRedoButtons();
    }

    // Redo last undone action
    function redo() {
      if (redoStack.length === 0) return;

      // Save current state to undo stack
      const currentState = {
        zones: JSON.parse(JSON.stringify(zones)),
        selectedZoneId: selectedZoneId,
        selectedZoneIds: [...selectedZoneIds]
      };
      undoStack.push(currentState);
      if (undoStack.length > MAX_HISTORY) {
        undoStack.shift();
      }

      // Restore next state
      const nextState = redoStack.pop();
      zones = nextState.zones;
      selectedZoneId = nextState.selectedZoneId;
      selectedZoneIds = nextState.selectedZoneIds || [];

      cancelDrawing();
      updateSelectionButtons();
      updateZonesList();
      renderZones();
      updateUndoRedoButtons();
    }

    // Update undo/redo button states
    function updateUndoRedoButtons() {
      const undoBtn = document.querySelector('.undo-btn');
      const redoBtn = document.querySelector('.redo-btn');
      if (undoBtn) undoBtn.disabled = undoStack.length === 0;
      if (redoBtn) redoBtn.disabled = redoStack.length === 0;
    }

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          originalImage = img;
          zones = [];
          selectedZoneId = null;
          selectedZoneIds = [];
          multiSelectMode = false;
          multiSelectBtn.classList.remove('active');
          undoStack = [];
          redoStack = [];
          cancelDrawing();
          updateSelectionButtons();
          updateZonesList();
          renderZones();
          updateUndoRedoButtons();

          const maxWidth = canvasArea.clientWidth - 24;
          const maxHeight = window.innerHeight * 0.5;
          const scaleX = maxWidth / img.width;
          const scaleY = maxHeight / img.height;
          scale = Math.min(scaleX, scaleY, 1);

          const displayWidth = img.width * scale;
          const displayHeight = img.height * scale;

          mainImage.src = event.target.result;
          mainImage.style.width = displayWidth + 'px';
          mainImage.style.height = displayHeight + 'px';
          imageContainer.style.width = displayWidth + 'px';
          imageContainer.style.height = displayHeight + 'px';
          svgOverlay.setAttribute('width', displayWidth);
          svgOverlay.setAttribute('height', displayHeight);
          svgOverlay.setAttribute('viewBox', `0 0 ${displayWidth} ${displayHeight}`);

          placeholder.style.display = 'none';
          imageContainer.style.display = 'block';
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    function getEventPos(e) {
      const rect = imageContainer.getBoundingClientRect();
      let clientX, clientY;

      if (e.touches && e.touches.length > 0) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else if (e.changedTouches && e.changedTouches.length > 0) {
        clientX = e.changedTouches[0].clientX;
        clientY = e.changedTouches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }

      return {
        x: Math.max(0, Math.min(clientX - rect.left, imageContainer.clientWidth)),
        y: Math.max(0, Math.min(clientY - rect.top, imageContainer.clientHeight))
      };
    }

    function findZoneAtPos(x, y) {
      for (let i = zones.length - 1; i >= 0; i--) {
        const z = zones[i];
        if (isPointInZone(x, y, z)) {
          return z;
        }
      }
      return null;
    }

    function isPointInZone(x, y, zone) {
      if (zone.type === 'rectangle') {
        return x >= zone.displayX && x <= zone.displayX + zone.displayW &&
               y >= zone.displayY && y <= zone.displayY + zone.displayH;
      } else if (zone.type === 'circle') {
        const cx = zone.displayX + zone.displayW / 2;
        const cy = zone.displayY + zone.displayH / 2;
        const rx = zone.displayW / 2;
        const ry = zone.displayH / 2;
        return Math.pow((x - cx) / rx, 2) + Math.pow((y - cy) / ry, 2) <= 1;
      } else if (zone.type === 'polygon' || zone.type === 'freehand') {
        return isPointInPolygon(x, y, zone.displayPoints);
      }
      return false;
    }

    function isPointInPolygon(x, y, points) {
      if (!points || points.length < 3) return false;
      let inside = false;
      for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
        const xi = points[i].x, yi = points[i].y;
        const xj = points[j].x, yj = points[j].y;
        if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
          inside = !inside;
        }
      }
      return inside;
    }

    function findAnchorAtPos(x, y, zone) {
      if (!zone) return -1;
      // Larger hit area for easier touch interaction (especially on mobile)
      const hitSize = 20;

      if (zone.type === 'rectangle') {
        const anchors = getRectAnchors(zone);
        for (let i = 0; i < anchors.length; i++) {
          const dist = Math.sqrt(Math.pow(x - anchors[i].x, 2) + Math.pow(y - anchors[i].y, 2));
          if (dist <= hitSize) {
            return i;
          }
        }
      } else if (zone.type === 'circle') {
        const anchors = getCircleAnchors(zone);
        for (let i = 0; i < anchors.length; i++) {
          const dist = Math.sqrt(Math.pow(x - anchors[i].x, 2) + Math.pow(y - anchors[i].y, 2));
          if (dist <= hitSize) {
            return i;
          }
        }
      } else if (zone.type === 'polygon' || zone.type === 'freehand') {
        for (let i = 0; i < zone.displayPoints.length; i++) {
          const dist = Math.sqrt(Math.pow(x - zone.displayPoints[i].x, 2) + Math.pow(y - zone.displayPoints[i].y, 2));
          if (dist <= hitSize) {
            return i;
          }
        }
      }
      return -1;
    }

    function getRectAnchors(zone) {
      const x = zone.displayX, y = zone.displayY;
      const w = zone.displayW, h = zone.displayH;
      return [
        { x: x, y: y, type: 'nw' },
        { x: x + w, y: y, type: 'ne' },
        { x: x + w, y: y + h, type: 'se' },
        { x: x, y: y + h, type: 'sw' },
        { x: x + w/2, y: y, type: 'n' },
        { x: x + w, y: y + h/2, type: 'e' },
        { x: x + w/2, y: y + h, type: 's' },
        { x: x, y: y + h/2, type: 'w' }
      ];
    }

    function getCircleAnchors(zone) {
      const cx = zone.displayX + zone.displayW / 2;
      const cy = zone.displayY + zone.displayH / 2;
      const rx = zone.displayW / 2;
      const ry = zone.displayH / 2;
      return [
        { x: cx, y: cy - ry, type: 'n' },
        { x: cx + rx, y: cy, type: 'e' },
        { x: cx, y: cy + ry, type: 's' },
        { x: cx - rx, y: cy, type: 'w' }
      ];
    }

    function findEdgeAtPos(x, y, zone) {
      if (!zone || (zone.type !== 'polygon' && zone.type !== 'freehand')) return -1;
      const hitDist = 10;
      const points = zone.displayPoints;

      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        const dist = pointToLineDistance(x, y, p1.x, p1.y, p2.x, p2.y);
        if (dist <= hitDist) {
          return i;
        }
      }
      return -1;
    }

    function pointToLineDistance(px, py, x1, y1, x2, y2) {
      const A = px - x1;
      const B = py - y1;
      const C = x2 - x1;
      const D = y2 - y1;
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = -1;
      if (lenSq !== 0) param = dot / lenSq;

      let xx, yy;
      if (param < 0) {
        xx = x1; yy = y1;
      } else if (param > 1) {
        xx = x2; yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }

      return Math.sqrt((px - xx) ** 2 + (py - yy) ** 2);
    }

    function startInteraction(e) {
      if (!originalImage) return;
      e.preventDefault();

      const pos = getEventPos(e);
      const now = Date.now();

      // Double-click detection
      const isDoubleClick = (now - lastClickTime < 300) &&
                           (Math.abs(pos.x - lastClickPos.x) < 10) &&
                           (Math.abs(pos.y - lastClickPos.y) < 10);
      lastClickTime = now;
      lastClickPos = { x: pos.x, y: pos.y };

      startX = pos.x;
      startY = pos.y;
      isDragging = false;

      // Handle polygon tool
      if (currentTool === 'polygon') {
        handlePolygonClick(pos, isDoubleClick);
        return;
      }

      // Handle freehand tool
      if (currentTool === 'freehand') {
        handleFreehandStart(pos);
        return;
      }

      // Check for double-click on edge to add anchor (for single selection)
      if (isDoubleClick && selectedZoneId) {
        const zone = zones.find(z => z.id === selectedZoneId);
        if (zone && (zone.type === 'polygon' || zone.type === 'freehand')) {
          const edgeIndex = findEdgeAtPos(pos.x, pos.y, zone);
          if (edgeIndex >= 0) {
            saveState();
            addAnchorToEdge(zone, edgeIndex, pos);
            return;
          }
        }
      }

      // Check if clicking an anchor on any selected zone
      const allSelectedIds = getSelectedZoneIds();
      for (const zoneId of allSelectedIds) {
        const zone = zones.find(z => z.id === zoneId);
        if (zone) {
          const anchorIndex = findAnchorAtPos(pos.x, pos.y, zone);
          if (anchorIndex >= 0) {
            saveState();
            action = 'resize-anchor';
            draggedAnchorIndex = anchorIndex;
            isDragging = true;

            // Store the zone being resized as primary
            if (multiSelectMode) {
              selectedZoneId = null;
              // Keep multi-selection but mark which zone's anchor is being dragged
            } else {
              selectedZoneId = zone.id;
            }

            startZone = JSON.parse(JSON.stringify(zone));
            // Store all selected zones for symmetric resize
            startZones = allSelectedIds.map(id => {
              const z = zones.find(zz => zz.id === id);
              return z ? JSON.parse(JSON.stringify(z)) : null;
            }).filter(z => z !== null);

            renderZones();
            return;
          }
        }
      }

      // Check if clicking inside a zone
      const clickedZone = findZoneAtPos(pos.x, pos.y);
      if (clickedZone) {
        if (multiSelectMode) {
          // In multi-select mode, toggle selection
          const idx = selectedZoneIds.indexOf(clickedZone.id);
          if (idx >= 0) {
            // Already selected - check if we should start moving or deselect
            // Start moving all selected zones
            action = 'move';
            isDragging = true;
            saveState();
            startZones = selectedZoneIds.map(id => {
              const z = zones.find(zz => zz.id === id);
              return z ? JSON.parse(JSON.stringify(z)) : null;
            }).filter(z => z !== null);
          } else {
            // Add to selection
            selectedZoneIds.push(clickedZone.id);
            updateSelectionButtons();
          }
        } else {
          selectedZoneId = clickedZone.id;
          action = 'move';
          isDragging = true;
          saveState();
          startZone = JSON.parse(JSON.stringify(clickedZone));
        }
        renderZones();
        updateZonesList();
        return;
      }

      // Pointer tool: only selection, no drawing
      if (currentTool === 'pointer') {
        if (!multiSelectMode) {
          selectedZoneId = null;
        }
        // In multi-select mode, clicking empty space doesn't clear selection
        renderZones();
        updateZonesList();
        updateSelectionButtons();
        return;
      }

      // Drawing new shape (for rectangle/circle tools)
      if (!multiSelectMode) {
        selectedZoneId = null;
      }
      action = 'draw';
      renderZones();
      updateZonesList();
    }

    function handlePolygonClick(pos, isDoubleClick) {
      if (!isDrawingPolygon) {
        // Start new polygon
        isDrawingPolygon = true;
        polygonPoints = [{ x: pos.x, y: pos.y }];
        selectedZoneId = null;
        renderZones();
        return;
      }

      // Check if clicking on first point to close polygon
      if (polygonPoints.length >= 3) {
        const firstPoint = polygonPoints[0];
        const dist = Math.sqrt((pos.x - firstPoint.x) ** 2 + (pos.y - firstPoint.y) ** 2);
        if (dist < 15) {
          // Close polygon
          finishPolygon();
          return;
        }
      }

      // Add new point
      polygonPoints.push({ x: pos.x, y: pos.y });
      renderZones();
    }

    function finishPolygon() {
      if (polygonPoints.length >= 3) {
        saveState();
        const bounds = getPointsBounds(polygonPoints);
        const newZone = {
          id: Date.now(),
          type: 'polygon',
          points: polygonPoints.map(p => ({ x: p.x / scale, y: p.y / scale })),
          displayPoints: [...polygonPoints],
          x: bounds.x / scale,
          y: bounds.y / scale,
          width: bounds.width / scale,
          height: bounds.height / scale,
          displayX: bounds.x,
          displayY: bounds.y,
          displayW: bounds.width,
          displayH: bounds.height
        };
        zones.push(newZone);
        selectedZoneId = newZone.id;
        updateZonesList();
      }

      polygonPoints = [];
      isDrawingPolygon = false;
      renderZones();
    }

    function handleFreehandStart(pos) {
      isDrawingFreehand = true;
      freehandPoints = [{ x: pos.x, y: pos.y }];
      action = 'freehand';
      selectedZoneId = null;
      renderZones();
    }

    function finishFreehand() {
      if (freehandPoints.length >= 5) {
        saveState();
        // Simplify the path to reduce points
        const simplified = simplifyPath(freehandPoints, 3);
        const bounds = getPointsBounds(simplified);

        const newZone = {
          id: Date.now(),
          type: 'freehand',
          points: simplified.map(p => ({ x: p.x / scale, y: p.y / scale })),
          displayPoints: [...simplified],
          x: bounds.x / scale,
          y: bounds.y / scale,
          width: bounds.width / scale,
          height: bounds.height / scale,
          displayX: bounds.x,
          displayY: bounds.y,
          displayW: bounds.width,
          displayH: bounds.height
        };
        zones.push(newZone);
        selectedZoneId = newZone.id;
        updateZonesList();
      }

      freehandPoints = [];
      isDrawingFreehand = false;
      action = null;
      renderZones();
    }

    function simplifyPath(points, tolerance) {
      if (points.length < 3) return points;

      // Douglas-Peucker algorithm
      let maxDist = 0;
      let maxIndex = 0;
      const first = points[0];
      const last = points[points.length - 1];

      for (let i = 1; i < points.length - 1; i++) {
        const dist = pointToLineDistance(points[i].x, points[i].y,
                                         first.x, first.y, last.x, last.y);
        if (dist > maxDist) {
          maxDist = dist;
          maxIndex = i;
        }
      }

      if (maxDist > tolerance) {
        const left = simplifyPath(points.slice(0, maxIndex + 1), tolerance);
        const right = simplifyPath(points.slice(maxIndex), tolerance);
        return [...left.slice(0, -1), ...right];
      }

      return [first, last];
    }

    function getPointsBounds(points) {
      const xs = points.map(p => p.x);
      const ys = points.map(p => p.y);
      const minX = Math.min(...xs);
      const minY = Math.min(...ys);
      return {
        x: minX,
        y: minY,
        width: Math.max(...xs) - minX,
        height: Math.max(...ys) - minY
      };
    }

    function addAnchorToEdge(zone, edgeIndex, pos) {
      const points = zone.displayPoints;
      const p1 = points[edgeIndex];
      const p2 = points[(edgeIndex + 1) % points.length];

      // Find closest point on edge
      const newPoint = getClosestPointOnLine(pos.x, pos.y, p1.x, p1.y, p2.x, p2.y);

      // Insert new point
      zone.displayPoints.splice(edgeIndex + 1, 0, newPoint);
      zone.points.splice(edgeIndex + 1, 0, { x: newPoint.x / scale, y: newPoint.y / scale });

      renderZones();
    }

    function getClosestPointOnLine(px, py, x1, y1, x2, y2) {
      const A = px - x1;
      const B = py - y1;
      const C = x2 - x1;
      const D = y2 - y1;
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = lenSq !== 0 ? dot / lenSq : -1;
      param = Math.max(0, Math.min(1, param));

      return {
        x: x1 + param * C,
        y: y1 + param * D
      };
    }

    function moveInteraction(e) {
      if (!action && !isDrawingPolygon && !isDrawingFreehand) return;
      e.preventDefault();

      const pos = getEventPos(e);
      const dx = pos.x - startX;
      const dy = pos.y - startY;
      const imgW = imageContainer.clientWidth;
      const imgH = imageContainer.clientHeight;

      // Mark as actively dragging if moved more than threshold
      if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
        isDragging = true;
      }

      if (action === 'freehand' && isDrawingFreehand) {
        freehandPoints.push({ x: pos.x, y: pos.y });
        renderZones();
        return;
      }

      if (isDrawingPolygon) {
        // Just render to show preview line
        renderZones(pos);
        return;
      }

      if (action === 'draw') {
        // Drawing rectangle or circle
        renderZones(null, {
          x: Math.min(startX, pos.x),
          y: Math.min(startY, pos.y),
          w: Math.abs(pos.x - startX),
          h: Math.abs(pos.y - startY)
        });
      }

      else if (action === 'move') {
        // Handle multi-zone movement
        if (multiSelectMode && startZones.length > 0) {
          moveMultipleZones(dx, dy, imgW, imgH);
        } else if (startZone) {
          // Single zone movement
          const zone = zones.find(z => z.id === selectedZoneId);
          if (!zone) return;
          moveSingleZone(zone, startZone, dx, dy, imgW, imgH);
        }
        renderZones();
      }

      else if (action === 'resize-anchor' && startZone && draggedAnchorIndex !== null) {
        // Handle anchor resize (with symmetric option for multi-select)
        if (multiSelectMode && startZones.length > 1) {
          resizeMultipleZones(pos, dx, dy, imgW, imgH);
        } else {
          resizeSingleZone(pos, imgW, imgH);
        }
        renderZones();
        updateZonesList();
      }
    }

    function moveSingleZone(zone, sourceZone, dx, dy, imgW, imgH) {
      // Calculate bounds
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      if (zone.type === 'polygon' || zone.type === 'freehand') {
        sourceZone.displayPoints.forEach(p => {
          minX = Math.min(minX, p.x);
          minY = Math.min(minY, p.y);
          maxX = Math.max(maxX, p.x);
          maxY = Math.max(maxY, p.y);
        });
      } else {
        minX = sourceZone.displayX;
        minY = sourceZone.displayY;
        maxX = sourceZone.displayX + sourceZone.displayW;
        maxY = sourceZone.displayY + sourceZone.displayH;
      }

      // Constrain movement
      let constrainedDx = dx;
      let constrainedDy = dy;
      if (minX + dx < 0) constrainedDx = -minX;
      if (minY + dy < 0) constrainedDy = -minY;
      if (maxX + dx > imgW) constrainedDx = imgW - maxX;
      if (maxY + dy > imgH) constrainedDy = imgH - maxY;

      if (zone.type === 'polygon' || zone.type === 'freehand') {
        zone.displayPoints = sourceZone.displayPoints.map(p => ({
          x: p.x + constrainedDx,
          y: p.y + constrainedDy
        }));
        zone.points = zone.displayPoints.map(p => ({ x: p.x / scale, y: p.y / scale }));
        const bounds = getPointsBounds(zone.displayPoints);
        zone.displayX = bounds.x;
        zone.displayY = bounds.y;
        zone.displayW = bounds.width;
        zone.displayH = bounds.height;
        zone.x = bounds.x / scale;
        zone.y = bounds.y / scale;
        zone.width = bounds.width / scale;
        zone.height = bounds.height / scale;
      } else {
        zone.displayX = sourceZone.displayX + constrainedDx;
        zone.displayY = sourceZone.displayY + constrainedDy;
        zone.x = zone.displayX / scale;
        zone.y = zone.displayY / scale;
      }
    }

    function moveMultipleZones(dx, dy, imgW, imgH) {
      // Calculate combined bounds of all selected zones
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

      startZones.forEach(sz => {
        if (sz.type === 'polygon' || sz.type === 'freehand') {
          sz.displayPoints.forEach(p => {
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x);
            maxY = Math.max(maxY, p.y);
          });
        } else {
          minX = Math.min(minX, sz.displayX);
          minY = Math.min(minY, sz.displayY);
          maxX = Math.max(maxX, sz.displayX + sz.displayW);
          maxY = Math.max(maxY, sz.displayY + sz.displayH);
        }
      });

      // Constrain movement for all zones together
      let constrainedDx = dx;
      let constrainedDy = dy;
      if (minX + dx < 0) constrainedDx = -minX;
      if (minY + dy < 0) constrainedDy = -minY;
      if (maxX + dx > imgW) constrainedDx = imgW - maxX;
      if (maxY + dy > imgH) constrainedDy = imgH - maxY;

      // Move all selected zones
      startZones.forEach(sz => {
        const zone = zones.find(z => z.id === sz.id);
        if (!zone) return;

        if (zone.type === 'polygon' || zone.type === 'freehand') {
          zone.displayPoints = sz.displayPoints.map(p => ({
            x: p.x + constrainedDx,
            y: p.y + constrainedDy
          }));
          zone.points = zone.displayPoints.map(p => ({ x: p.x / scale, y: p.y / scale }));
          const bounds = getPointsBounds(zone.displayPoints);
          zone.displayX = bounds.x;
          zone.displayY = bounds.y;
          zone.displayW = bounds.width;
          zone.displayH = bounds.height;
          zone.x = bounds.x / scale;
          zone.y = bounds.y / scale;
          zone.width = bounds.width / scale;
          zone.height = bounds.height / scale;
        } else {
          zone.displayX = sz.displayX + constrainedDx;
          zone.displayY = sz.displayY + constrainedDy;
          zone.x = zone.displayX / scale;
          zone.y = zone.displayY / scale;
        }
      });
    }

    function resizeSingleZone(pos, imgW, imgH) {
      const zone = zones.find(z => z.id === startZone.id);
      if (!zone) return;

      if (zone.type === 'rectangle') {
        resizeRectangle(zone, pos);
      } else if (zone.type === 'circle') {
        resizeCircle(zone, pos);
      } else if (zone.type === 'polygon' || zone.type === 'freehand') {
        // Move individual anchor point
        const constrainedX = Math.max(0, Math.min(pos.x, imgW));
        const constrainedY = Math.max(0, Math.min(pos.y, imgH));
        zone.displayPoints[draggedAnchorIndex] = { x: constrainedX, y: constrainedY };
        zone.points[draggedAnchorIndex] = { x: constrainedX / scale, y: constrainedY / scale };

        const bounds = getPointsBounds(zone.displayPoints);
        zone.displayX = bounds.x;
        zone.displayY = bounds.y;
        zone.displayW = bounds.width;
        zone.displayH = bounds.height;
        zone.x = bounds.x / scale;
        zone.y = bounds.y / scale;
        zone.width = bounds.width / scale;
        zone.height = bounds.height / scale;
      }
    }

    function resizeMultipleZones(pos, dx, dy, imgW, imgH) {
      // For symmetric resizing, calculate the scale factor based on the primary zone
      const primaryZone = zones.find(z => z.id === startZone.id);
      if (!primaryZone) return;

      // First resize the primary zone
      resizeSingleZone(pos, imgW, imgH);

      // Calculate scale factors from primary zone's resize
      const scaleX = primaryZone.displayW / startZone.displayW;
      const scaleY = primaryZone.displayH / startZone.displayH;

      // Apply proportional resize to other selected zones
      startZones.forEach(sz => {
        if (sz.id === startZone.id) return; // Skip primary zone

        const zone = zones.find(z => z.id === sz.id);
        if (!zone) return;

        if (zone.type === 'rectangle' || zone.type === 'circle') {
          // Calculate new dimensions maintaining proportions
          const newW = sz.displayW * scaleX;
          const newH = sz.displayH * scaleY;

          // Keep center position, adjust bounds
          const centerX = sz.displayX + sz.displayW / 2;
          const centerY = sz.displayY + sz.displayH / 2;

          zone.displayW = Math.max(20, newW);
          zone.displayH = Math.max(20, newH);
          zone.displayX = Math.max(0, Math.min(centerX - zone.displayW / 2, imgW - zone.displayW));
          zone.displayY = Math.max(0, Math.min(centerY - zone.displayH / 2, imgH - zone.displayH));

          zone.x = zone.displayX / scale;
          zone.y = zone.displayY / scale;
          zone.width = zone.displayW / scale;
          zone.height = zone.displayH / scale;
        } else if (zone.type === 'polygon' || zone.type === 'freehand') {
          // Scale polygon points around center
          const bounds = getPointsBounds(sz.displayPoints);
          const centerX = bounds.x + bounds.width / 2;
          const centerY = bounds.y + bounds.height / 2;

          zone.displayPoints = sz.displayPoints.map(p => ({
            x: Math.max(0, Math.min(centerX + (p.x - centerX) * scaleX, imgW)),
            y: Math.max(0, Math.min(centerY + (p.y - centerY) * scaleY, imgH))
          }));
          zone.points = zone.displayPoints.map(p => ({ x: p.x / scale, y: p.y / scale }));

          const newBounds = getPointsBounds(zone.displayPoints);
          zone.displayX = newBounds.x;
          zone.displayY = newBounds.y;
          zone.displayW = newBounds.width;
          zone.displayH = newBounds.height;
          zone.x = newBounds.x / scale;
          zone.y = newBounds.y / scale;
          zone.width = newBounds.width / scale;
          zone.height = newBounds.height / scale;
        }
      });
    }

    function resizeRectangle(zone, pos) {
      const anchors = getRectAnchors(startZone);
      const anchor = anchors[draggedAnchorIndex];
      const imgW = imageContainer.clientWidth;
      const imgH = imageContainer.clientHeight;
      const minSize = 20;

      let newX = startZone.displayX;
      let newY = startZone.displayY;
      let newW = startZone.displayW;
      let newH = startZone.displayH;

      const type = anchor.type;

      if (type.includes('w')) {
        newX = Math.max(0, Math.min(pos.x, startZone.displayX + startZone.displayW - minSize));
        newW = startZone.displayX + startZone.displayW - newX;
      }
      if (type.includes('e')) {
        newW = Math.max(minSize, Math.min(pos.x - startZone.displayX, imgW - startZone.displayX));
      }
      if (type.includes('n')) {
        newY = Math.max(0, Math.min(pos.y, startZone.displayY + startZone.displayH - minSize));
        newH = startZone.displayY + startZone.displayH - newY;
      }
      if (type.includes('s')) {
        newH = Math.max(minSize, Math.min(pos.y - startZone.displayY, imgH - startZone.displayY));
      }

      zone.displayX = newX;
      zone.displayY = newY;
      zone.displayW = newW;
      zone.displayH = newH;
      zone.x = newX / scale;
      zone.y = newY / scale;
      zone.width = newW / scale;
      zone.height = newH / scale;
    }

    function resizeCircle(zone, pos) {
      const anchors = getCircleAnchors(startZone);
      const anchor = anchors[draggedAnchorIndex];
      const imgW = imageContainer.clientWidth;
      const imgH = imageContainer.clientHeight;
      const minSize = 20;

      const cx = startZone.displayX + startZone.displayW / 2;
      const cy = startZone.displayY + startZone.displayH / 2;

      let newX = startZone.displayX;
      let newY = startZone.displayY;
      let newW = startZone.displayW;
      let newH = startZone.displayH;

      if (anchor.type === 'n') {
        const newRy = Math.max(minSize/2, cy - Math.max(0, pos.y));
        newY = cy - newRy;
        newH = newRy * 2;
      } else if (anchor.type === 's') {
        const newRy = Math.max(minSize/2, Math.min(pos.y, imgH) - cy);
        newY = cy - newRy;
        newH = newRy * 2;
      } else if (anchor.type === 'w') {
        const newRx = Math.max(minSize/2, cx - Math.max(0, pos.x));
        newX = cx - newRx;
        newW = newRx * 2;
      } else if (anchor.type === 'e') {
        const newRx = Math.max(minSize/2, Math.min(pos.x, imgW) - cx);
        newX = cx - newRx;
        newW = newRx * 2;
      }

      zone.displayX = newX;
      zone.displayY = newY;
      zone.displayW = newW;
      zone.displayH = newH;
      zone.x = newX / scale;
      zone.y = newY / scale;
      zone.width = newW / scale;
      zone.height = newH / scale;
    }

    function endInteraction(e) {
      if (isDrawingFreehand) {
        finishFreehand();
        return;
      }

      if (isDrawingPolygon) {
        // Don't end polygon on mouseup, it ends on click of first point
        return;
      }

      if (!action) return;
      e.preventDefault();

      if (action === 'draw') {
        const pos = getEventPos(e);
        const imgW = imageContainer.clientWidth;
        const imgH = imageContainer.clientHeight;

        const left = Math.max(0, Math.min(startX, pos.x));
        const top = Math.max(0, Math.min(startY, pos.y));
        const right = Math.min(imgW, Math.max(startX, pos.x));
        const bottom = Math.min(imgH, Math.max(startY, pos.y));
        const width = right - left;
        const height = bottom - top;

        if (width > 10 && height > 10) {
          saveState();
          const newZone = {
            id: Date.now(),
            type: currentTool === 'circle' ? 'circle' : 'rectangle',
            x: left / scale,
            y: top / scale,
            width: width / scale,
            height: height / scale,
            displayX: left,
            displayY: top,
            displayW: width,
            displayH: height
          };
          zones.push(newZone);
          if (multiSelectMode) {
            selectedZoneIds.push(newZone.id);
            selectedZoneId = null;
          } else {
            selectedZoneId = newZone.id;
          }
          updateZonesList();
          updateSelectionButtons();
        }
      }

      action = null;
      draggedAnchorIndex = null;
      startZone = null;
      startZones = [];
      isDragging = false;
      renderZones();
    }

    // Mouse events
    imageContainer.addEventListener('mousedown', startInteraction);
    window.addEventListener('mousemove', moveInteraction);
    window.addEventListener('mouseup', endInteraction);

    // Touch events
    imageContainer.addEventListener('touchstart', startInteraction, { passive: false });
    window.addEventListener('touchmove', moveInteraction, { passive: false });
    window.addEventListener('touchend', endInteraction, { passive: false });
    window.addEventListener('touchcancel', endInteraction, { passive: false });

    // Keyboard events
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        cancelDrawing();
        // Also exit multi-select mode on Escape
        if (multiSelectMode) {
          toggleMultiSelectMode();
        }
      } else if (e.key === 'Delete' || e.key === 'Backspace') {
        if (!isDrawingPolygon && !isDrawingFreehand) {
          // Delete all selected zones
          const toDelete = getSelectedZoneIds();
          if (toDelete.length > 0) {
            saveState();
            zones = zones.filter(z => !toDelete.includes(z.id));
            selectedZoneId = null;
            selectedZoneIds = [];
            updateSelectionButtons();
            updateZonesList();
            renderZones();
          }
        }
      } else if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
      } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        redo();
      }
    });

    function updateZonesList() {
      zoneCount.textContent = zones.length;
      emptyMsg.style.display = zones.length === 0 ? 'block' : 'none';
      exportBtn.disabled = zones.length === 0;
      exportBtn.textContent = `Export ${zones.length} Zone${zones.length !== 1 ? 's' : ''}`;

      zoneItems.innerHTML = zones.map((z, i) => {
        const dims = `${Math.round(z.width)}Ã—${Math.round(z.height)}`;
        const typeLabel = z.type.charAt(0).toUpperCase() + z.type.slice(1);
        const isMultiSelected = selectedZoneIds.includes(z.id);
        const isSingleSelected = z.id === selectedZoneId;
        let itemClass = 'zone-item';
        if (isSingleSelected) itemClass += ' selected';
        if (isMultiSelected) itemClass += ' multi-selected';

        return `
          <div class="${itemClass}" onclick="selectZone(${z.id})" ontouchend="handleZoneItemTouch(event, ${z.id})">
            <span>
              <strong>#${i + 1}</strong>
              <span class="dims">${dims}</span>
              <span class="type-badge">${typeLabel}</span>
            </span>
            <button class="delete-btn" onclick="event.stopPropagation(); deleteZone(${z.id})" ontouchend="event.stopPropagation(); deleteZone(${z.id})">âœ•</button>
          </div>
        `;
      }).join('');
    }

    // Handle touch on zone items for better mobile experience
    function handleZoneItemTouch(e, zoneId) {
      e.preventDefault();
      selectZone(zoneId);
    }

    function renderZones(mousePos = null, drawPreview = null) {
      let svg = '';

      // Render existing zones
      zones.forEach((z, i) => {
        const isSelected = z.id === selectedZoneId;
        const isMultiSelected = selectedZoneIds.includes(z.id);
        svg += renderZoneShape(z, i, isSelected, isMultiSelected);
      });

      // Render polygon being drawn
      if (isDrawingPolygon && polygonPoints.length > 0) {
        // Draw completed segments
        if (polygonPoints.length > 1) {
          const pathD = polygonPoints.map((p, i) =>
            `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`
          ).join(' ');
          svg += `<path d="${pathD}" class="drawing-preview" fill="none"/>`;
        }

        // Draw preview line to mouse position
        if (mousePos) {
          const lastPoint = polygonPoints[polygonPoints.length - 1];
          svg += `<line x1="${lastPoint.x}" y1="${lastPoint.y}" x2="${mousePos.x}" y2="${mousePos.y}" class="drawing-line"/>`;
        }

        // Draw anchor points
        polygonPoints.forEach((p, i) => {
          const isFirst = i === 0;
          svg += `<circle cx="${p.x}" cy="${p.y}" r="${isFirst ? 8 : 6}" class="anchor-point ${isFirst ? 'first-anchor' : ''}"/>`;
        });
      }

      // Render freehand being drawn
      if (isDrawingFreehand && freehandPoints.length > 1) {
        const pathD = freehandPoints.map((p, i) =>
          `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`
        ).join(' ');
        svg += `<path d="${pathD}" class="drawing-preview" fill="none"/>`;
      }

      // Render rectangle/circle preview
      if (drawPreview && action === 'draw') {
        if (currentTool === 'circle') {
          const cx = drawPreview.x + drawPreview.w / 2;
          const cy = drawPreview.y + drawPreview.h / 2;
          svg += `<ellipse cx="${cx}" cy="${cy}" rx="${drawPreview.w/2}" ry="${drawPreview.h/2}" class="drawing-preview"/>`;
        } else {
          svg += `<rect x="${drawPreview.x}" y="${drawPreview.y}" width="${drawPreview.w}" height="${drawPreview.h}" class="drawing-preview"/>`;
        }
      }

      svgOverlay.innerHTML = svg;
    }

    function renderZoneShape(zone, index, isSelected, isMultiSelected = false) {
      let svg = '';
      let shapeClass = 'zone-shape';
      if (isSelected) shapeClass += ' selected';
      if (isMultiSelected) shapeClass += ' multi-selected';
      if (isDragging && (isSelected || isMultiSelected)) shapeClass += ' dragging';

      // Show anchors for selected or multi-selected zones
      const showAnchors = isSelected || isMultiSelected;

      if (zone.type === 'rectangle') {
        svg += `<rect x="${zone.displayX}" y="${zone.displayY}" width="${zone.displayW}" height="${zone.displayH}"
                      class="${shapeClass}" data-zone-id="${zone.id}"/>`;

        // Label
        svg += renderZoneLabel(zone.displayX + 4, zone.displayY + 4, index + 1, isSelected, isMultiSelected);

        // Anchors for selected zone
        if (showAnchors) {
          const anchors = getRectAnchors(zone);
          anchors.forEach((a, i) => {
            // Larger invisible hit area for easier touch interaction
            svg += `<rect x="${a.x - 14}" y="${a.y - 14}" width="28" height="28" class="anchor-hit-area" data-anchor="${i}" data-zone="${zone.id}"/>`;
            // Visible anchor point
            const draggingClass = (action === 'resize-anchor' && draggedAnchorIndex === i && startZone && startZone.id === zone.id) ? ' dragging' : '';
            svg += `<rect x="${a.x - 7}" y="${a.y - 7}" width="14" height="14" rx="3" class="anchor-point${draggingClass}" data-anchor="${i}" data-zone="${zone.id}"/>`;
          });
        }
      }
      else if (zone.type === 'circle') {
        const cx = zone.displayX + zone.displayW / 2;
        const cy = zone.displayY + zone.displayH / 2;
        svg += `<ellipse cx="${cx}" cy="${cy}" rx="${zone.displayW/2}" ry="${zone.displayH/2}"
                         class="${shapeClass}" data-zone-id="${zone.id}"/>`;

        // Label
        svg += renderZoneLabel(zone.displayX + 4, zone.displayY + 4, index + 1, isSelected, isMultiSelected);

        // Anchors for selected zone
        if (showAnchors) {
          const anchors = getCircleAnchors(zone);
          anchors.forEach((a, i) => {
            // Larger invisible hit area
            svg += `<circle cx="${a.x}" cy="${a.y}" r="14" class="anchor-hit-area" data-anchor="${i}" data-zone="${zone.id}"/>`;
            // Visible anchor point
            const draggingClass = (action === 'resize-anchor' && draggedAnchorIndex === i && startZone && startZone.id === zone.id) ? ' dragging' : '';
            svg += `<circle cx="${a.x}" cy="${a.y}" r="8" class="anchor-point${draggingClass}" data-anchor="${i}" data-zone="${zone.id}"/>`;
          });
        }
      }
      else if (zone.type === 'polygon' || zone.type === 'freehand') {
        const pathD = zone.displayPoints.map((p, i) =>
          `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`
        ).join(' ') + ' Z';
        svg += `<path d="${pathD}" class="${shapeClass}" data-zone-id="${zone.id}"/>`;

        // Label
        svg += renderZoneLabel(zone.displayX + 4, zone.displayY + 4, index + 1, isSelected, isMultiSelected);

        // Anchors and edge highlights for selected zone
        if (showAnchors) {
          // Edge highlights for adding new anchors (only for single selection)
          if (isSelected && !isMultiSelected) {
            for (let i = 0; i < zone.displayPoints.length; i++) {
              const p1 = zone.displayPoints[i];
              const p2 = zone.displayPoints[(i + 1) % zone.displayPoints.length];
              svg += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" class="edge-highlight" data-edge="${i}"/>`;
            }
          }

          // Anchor points
          zone.displayPoints.forEach((p, i) => {
            // Larger invisible hit area
            svg += `<circle cx="${p.x}" cy="${p.y}" r="14" class="anchor-hit-area" data-anchor="${i}" data-zone="${zone.id}"/>`;
            // Visible anchor point
            const draggingClass = (action === 'resize-anchor' && draggedAnchorIndex === i && startZone && startZone.id === zone.id) ? ' dragging' : '';
            svg += `<circle cx="${p.x}" cy="${p.y}" r="8" class="anchor-point${draggingClass}" data-anchor="${i}" data-zone="${zone.id}"/>`;
          });
        }
      }

      return svg;
    }

    function renderZoneLabel(x, y, number, isSelected, isMultiSelected = false) {
      const text = String(number);
      const width = text.length * 8 + 14;
      let bgClass = 'zone-label-bg';
      if (isSelected) bgClass += ' selected';
      if (isMultiSelected) bgClass += ' multi-selected';
      return `
        <rect x="${x}" y="${y}" width="${width}" height="20" rx="4" class="${bgClass}"/>
        <text x="${x + width/2}" y="${y + 14}" text-anchor="middle" class="zone-label-svg">${number}</text>
      `;
    }

    function selectZone(id) {
      if (multiSelectMode) {
        // Toggle selection in multi-select mode
        const idx = selectedZoneIds.indexOf(id);
        if (idx >= 0) {
          selectedZoneIds.splice(idx, 1);
        } else {
          selectedZoneIds.push(id);
        }
        selectedZoneId = null;
      } else {
        selectedZoneId = id;
        selectedZoneIds = [];
      }
      updateSelectionButtons();
      renderZones();
      updateZonesList();
    }

    function deleteZone(id) {
      saveState();
      zones = zones.filter(z => z.id !== id);
      if (selectedZoneId === id) selectedZoneId = null;
      // Remove from multi-selection as well
      const idx = selectedZoneIds.indexOf(id);
      if (idx >= 0) selectedZoneIds.splice(idx, 1);
      updateSelectionButtons();
      updateZonesList();
      renderZones();
    }

    function clearAllZones() {
      if (zones.length > 0) {
        saveState();
      }
      zones = [];
      selectedZoneId = null;
      selectedZoneIds = [];
      cancelDrawing();
      updateSelectionButtons();
      updateZonesList();
      renderZones();
    }

    function exportZones() {
      if (!originalImage || zones.length === 0) return;
      const baseName = baseNameInput.value || 'zone';

      zones.forEach((zone, index) => {
        const canvas = document.createElement('canvas');
        // Use ceil to ensure we don't cut off any pixels at boundaries
        const canvasWidth = Math.ceil(zone.width);
        const canvasHeight = Math.ceil(zone.height);
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext('2d');

        // Disable image smoothing for pixel-perfect quality at original resolution
        ctx.imageSmoothingEnabled = false;

        if (zone.type === 'rectangle') {
          // Use precise coordinates for highest quality
          ctx.drawImage(
            originalImage,
            zone.x, zone.y,
            zone.width, zone.height,
            0, 0,
            canvasWidth, canvasHeight
          );
        }
        else if (zone.type === 'circle') {
          // Draw full bounding box first
          ctx.drawImage(
            originalImage,
            zone.x, zone.y,
            zone.width, zone.height,
            0, 0,
            canvasWidth, canvasHeight
          );

          // Apply elliptical mask
          ctx.globalCompositeOperation = 'destination-in';
          ctx.beginPath();
          ctx.ellipse(
            canvasWidth / 2, canvasHeight / 2,
            canvasWidth / 2, canvasHeight / 2,
            0, 0, Math.PI * 2
          );
          ctx.fill();
        }
        else if (zone.type === 'polygon' || zone.type === 'freehand') {
          // Create clipping path from polygon points
          ctx.save();
          ctx.beginPath();
          zone.points.forEach((p, i) => {
            // Scale points to canvas coordinates
            const x = (p.x - zone.x) * (canvasWidth / zone.width);
            const y = (p.y - zone.y) * (canvasHeight / zone.height);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          });
          ctx.closePath();
          ctx.clip();

          // Draw image
          ctx.drawImage(
            originalImage,
            zone.x, zone.y,
            zone.width, zone.height,
            0, 0,
            canvasWidth, canvasHeight
          );
          ctx.restore();

          // Apply mask for transparent background outside polygon
          const maskCanvas = document.createElement('canvas');
          maskCanvas.width = canvasWidth;
          maskCanvas.height = canvasHeight;
          const maskCtx = maskCanvas.getContext('2d');
          maskCtx.imageSmoothingEnabled = false;

          maskCtx.fillStyle = 'white';
          maskCtx.beginPath();
          zone.points.forEach((p, i) => {
            // Scale points to canvas coordinates
            const x = (p.x - zone.x) * (canvasWidth / zone.width);
            const y = (p.y - zone.y) * (canvasHeight / zone.height);
            if (i === 0) maskCtx.moveTo(x, y);
            else maskCtx.lineTo(x, y);
          });
          maskCtx.closePath();
          maskCtx.fill();

          ctx.globalCompositeOperation = 'destination-in';
          ctx.drawImage(maskCanvas, 0, 0);
        }

        const link = document.createElement('a');
        link.download = `${baseName}_${String(index + 1).padStart(2, '0')}.png`;
        // Export as PNG with maximum quality (PNG is lossless)
        link.href = canvas.toDataURL('image/png');
        link.click();
      });
    }

    // Prevent page scroll while interacting on mobile
    document.body.addEventListener('touchmove', (e) => {
      if (action || isDrawingPolygon || isDrawingFreehand) e.preventDefault();
    }, { passive: false });

    // ========================================
    // PRESET GRID FUNCTIONS
    // ========================================

    // Toggle preset category expansion
    function togglePresetCategory(categoryId) {
      const category = document.getElementById(categoryId);
      if (category) {
        category.classList.toggle('expanded');
      }
    }

    // Golden ratio constant
    const PHI = 1.618033988749895;

    // Apply a preset grid to the current image
    function applyPreset(presetType) {
      if (!originalImage) {
        alert('Please load an image first');
        return;
      }

      // Save state for undo
      saveState();

      // Clear existing zones
      zones = [];
      selectedZoneId = null;
      cancelDrawing();

      const imgW = originalImage.width;
      const imgH = originalImage.height;

      let newZones = [];

      switch (presetType) {
        // Compositional Grids
        case 'rule-of-thirds':
          newZones = generateMosaicGrid(imgW, imgH, 3, 3);
          break;
        case 'phi-grid':
          newZones = generatePhiGrid(imgW, imgH);
          break;
        case 'golden-triangle':
          newZones = generateGoldenTriangle(imgW, imgH);
          break;

        // Social Media Grids
        case 'social-1x1-3':
          newZones = generateSquareTiles(imgW, imgH, 3);
          break;
        case 'social-1x1-9':
          newZones = generateSquareTiles(imgW, imgH, 9);
          break;
        case 'social-4x5':
          newZones = generateAspectRatioCrop(imgW, imgH, 4, 5);
          break;
        case 'social-9x16':
          newZones = generateAspectRatioCrop(imgW, imgH, 9, 16);
          break;

        // Print Aspect Ratios
        case 'ratio-3x2':
          newZones = generateAspectRatioCrop(imgW, imgH, 3, 2);
          break;
        case 'ratio-4x3':
          newZones = generateAspectRatioCrop(imgW, imgH, 4, 3);
          break;
        case 'ratio-5x4':
          newZones = generateAspectRatioCrop(imgW, imgH, 5, 4);
          break;
        case 'ratio-16x9':
          newZones = generateAspectRatioCrop(imgW, imgH, 16, 9);
          break;

        // Mosaic Splitter
        case 'mosaic-2x2':
          newZones = generateMosaicGrid(imgW, imgH, 2, 2);
          break;
        case 'mosaic-3x3':
          newZones = generateMosaicGrid(imgW, imgH, 3, 3);
          break;
        case 'mosaic-4x4':
          newZones = generateMosaicGrid(imgW, imgH, 4, 4);
          break;
        case 'mosaic-2x3':
          newZones = generateMosaicGrid(imgW, imgH, 2, 3);
          break;
        case 'mosaic-3x1':
          newZones = generateMosaicGrid(imgW, imgH, 3, 1);
          break;
        case 'mosaic-1x3':
          newZones = generateMosaicGrid(imgW, imgH, 1, 3);
          break;

        default:
          console.warn('Unknown preset:', presetType);
          return;
      }

      // Add zones with proper display coordinates
      newZones.forEach(zone => {
        zone.displayX = zone.x * scale;
        zone.displayY = zone.y * scale;
        zone.displayW = zone.width * scale;
        zone.displayH = zone.height * scale;

        // For polygon/freehand types, also scale the points
        if (zone.points && zone.points.length > 0) {
          zone.displayPoints = zone.points.map(p => ({
            x: p.x * scale,
            y: p.y * scale
          }));
        }

        zones.push(zone);
      });

      updateZonesList();
      renderZones();
    }

    // Generate a simple mosaic grid (rows x cols of equal rectangles)
    function generateMosaicGrid(imgW, imgH, cols, rows) {
      const cellW = imgW / cols;
      const cellH = imgH / rows;
      const zones = [];

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          zones.push({
            id: Date.now() + row * cols + col,
            type: 'rectangle',
            x: col * cellW,
            y: row * cellH,
            width: cellW,
            height: cellH
          });
        }
      }

      return zones;
    }

    // Generate Phi Grid (golden ratio divisions)
    function generatePhiGrid(imgW, imgH) {
      // Phi grid divides the image using golden ratio proportions
      // Instead of 1/3 divisions, use 1/phi and 1-1/phi
      const phiRatio = 1 / PHI; // ~0.618
      const phiComplement = 1 - phiRatio; // ~0.382

      // Vertical divisions at golden ratio points
      const x1 = imgW * phiComplement;
      const x2 = imgW * phiRatio;

      // Horizontal divisions at golden ratio points
      const y1 = imgH * phiComplement;
      const y2 = imgH * phiRatio;

      const zones = [];

      // Top row
      zones.push({ id: Date.now(), type: 'rectangle', x: 0, y: 0, width: x1, height: y1 });
      zones.push({ id: Date.now() + 1, type: 'rectangle', x: x1, y: 0, width: x2 - x1, height: y1 });
      zones.push({ id: Date.now() + 2, type: 'rectangle', x: x2, y: 0, width: imgW - x2, height: y1 });

      // Middle row
      zones.push({ id: Date.now() + 3, type: 'rectangle', x: 0, y: y1, width: x1, height: y2 - y1 });
      zones.push({ id: Date.now() + 4, type: 'rectangle', x: x1, y: y1, width: x2 - x1, height: y2 - y1 });
      zones.push({ id: Date.now() + 5, type: 'rectangle', x: x2, y: y1, width: imgW - x2, height: y2 - y1 });

      // Bottom row
      zones.push({ id: Date.now() + 6, type: 'rectangle', x: 0, y: y2, width: x1, height: imgH - y2 });
      zones.push({ id: Date.now() + 7, type: 'rectangle', x: x1, y: y2, width: x2 - x1, height: imgH - y2 });
      zones.push({ id: Date.now() + 8, type: 'rectangle', x: x2, y: y2, width: imgW - x2, height: imgH - y2 });

      return zones;
    }

    // Generate Golden Triangle grid (diagonal composition)
    function generateGoldenTriangle(imgW, imgH) {
      // Golden triangle creates triangular zones for dynamic composition
      // We'll create 4 triangular regions as polygons
      const zones = [];

      // Main diagonal from top-left to bottom-right
      // Perpendicular from top-right to main diagonal
      // Perpendicular from bottom-left to main diagonal

      // Calculate intersection points
      // For a rectangle, the perpendicular from top-right corner meets the diagonal at:
      const diagonalLength = Math.sqrt(imgW * imgW + imgH * imgH);
      const t1 = (imgW * imgW) / (diagonalLength * diagonalLength) * diagonalLength;

      // Point on diagonal from top-left
      const px1 = (imgW * imgW) / diagonalLength * (imgW / diagonalLength);
      const py1 = (imgW * imgW) / diagonalLength * (imgH / diagonalLength);

      // Point on diagonal from bottom-left
      const px2 = imgW - (imgH * imgH) / diagonalLength * (imgW / diagonalLength);
      const py2 = imgH - (imgH * imgH) / diagonalLength * (imgH / diagonalLength);

      // Create 4 triangular zones as polygons
      // Top triangle (top-left corner to top-right to intersection point 1)
      zones.push({
        id: Date.now(),
        type: 'polygon',
        points: [
          { x: 0, y: 0 },
          { x: imgW, y: 0 },
          { x: px1, y: py1 }
        ],
        x: 0,
        y: 0,
        width: imgW,
        height: py1
      });

      // Right triangle (top-right to bottom-right to intersection point 2)
      zones.push({
        id: Date.now() + 1,
        type: 'polygon',
        points: [
          { x: imgW, y: 0 },
          { x: imgW, y: imgH },
          { x: px2, y: py2 },
          { x: px1, y: py1 }
        ],
        x: px1,
        y: 0,
        width: imgW - px1,
        height: imgH
      });

      // Bottom triangle (bottom-right to bottom-left to intersection point 2)
      zones.push({
        id: Date.now() + 2,
        type: 'polygon',
        points: [
          { x: imgW, y: imgH },
          { x: 0, y: imgH },
          { x: px2, y: py2 }
        ],
        x: 0,
        y: py2,
        width: imgW,
        height: imgH - py2
      });

      // Left triangle (bottom-left to top-left to intersection point 1)
      zones.push({
        id: Date.now() + 3,
        type: 'polygon',
        points: [
          { x: 0, y: imgH },
          { x: 0, y: 0 },
          { x: px1, y: py1 },
          { x: px2, y: py2 }
        ],
        x: 0,
        y: 0,
        width: px2,
        height: imgH
      });

      return zones;
    }

    // Generate square tiles from the largest square that fits the image
    function generateSquareTiles(imgW, imgH, count) {
      const zones = [];

      // For 3 tiles: create 3 squares in a row
      // For 9 tiles: create 3x3 grid of squares
      if (count === 3) {
        // 3 horizontal squares - use the height as the square size if image is wider
        // or divide width by 3 if image is taller
        const squareSize = Math.min(imgH, imgW / 3);
        const totalWidth = squareSize * 3;
        const startX = (imgW - totalWidth) / 2;
        const startY = (imgH - squareSize) / 2;

        for (let i = 0; i < 3; i++) {
          zones.push({
            id: Date.now() + i,
            type: 'rectangle',
            x: startX + i * squareSize,
            y: startY,
            width: squareSize,
            height: squareSize
          });
        }
      } else if (count === 9) {
        // 3x3 grid of squares - find the largest 3x3 arrangement
        const squareSize = Math.min(imgW / 3, imgH / 3);
        const totalWidth = squareSize * 3;
        const totalHeight = squareSize * 3;
        const startX = (imgW - totalWidth) / 2;
        const startY = (imgH - totalHeight) / 2;

        for (let row = 0; row < 3; row++) {
          for (let col = 0; col < 3; col++) {
            zones.push({
              id: Date.now() + row * 3 + col,
              type: 'rectangle',
              x: startX + col * squareSize,
              y: startY + row * squareSize,
              width: squareSize,
              height: squareSize
            });
          }
        }
      }

      return zones;
    }

    // Generate a centered crop with specific aspect ratio
    function generateAspectRatioCrop(imgW, imgH, ratioW, ratioH) {
      const zones = [];

      // Calculate the largest area with the target aspect ratio that fits
      const targetRatio = ratioW / ratioH;
      const imageRatio = imgW / imgH;

      let cropW, cropH;

      if (imageRatio > targetRatio) {
        // Image is wider than target ratio - height is limiting
        cropH = imgH;
        cropW = imgH * targetRatio;
      } else {
        // Image is taller than target ratio - width is limiting
        cropW = imgW;
        cropH = imgW / targetRatio;
      }

      // Center the crop
      const startX = (imgW - cropW) / 2;
      const startY = (imgH - cropH) / 2;

      zones.push({
        id: Date.now(),
        type: 'rectangle',
        x: startX,
        y: startY,
        width: cropW,
        height: cropH
      });

      return zones;
    }

    // Initialize hint and button states
    setTool('rectangle');
    updateUndoRedoButtons();
    updateSelectionButtons();
  </script>
</body>
</html>
